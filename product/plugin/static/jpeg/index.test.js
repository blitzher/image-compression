describe('JPEG methods', () => {
    let jpeg;

    before(async () => {
        jpeg = await JPEG({
            srcUri: './static/index.png',
            canvas: document.getElementById('canvas'),
        });
    });

    let testMcu = [
        [140, 144, 147, 140, 140, 155, 179, 175],
        [144, 152, 140, 147, 140, 148, 167, 179],
        [152, 155, 136, 167, 163, 162, 152, 172],
        [168, 145, 156, 160, 152, 155, 136, 160],
        [162, 148, 156, 148, 140, 136, 147, 162],
        [147, 167, 140, 155, 155, 140, 136, 162],
        [136, 156, 123, 167, 162, 144, 140, 147],
        [148, 155, 136, 155, 152, 147, 147, 136],
    ];

    let dctMcu = [
        [1210, -18, 15, -9, 23, -9, -14, -19],
        [21, -34, 26, -9, -11, 11, 14, 7],
        [-10, -24, -2, 6, -18, 3, -20, -1],
        [-8, -5, 14, -15, -8, -3, -3, 8],
        [-3, 10, 8, 1, -11, 18, 18, 15],
        [4, -2, -18, 8, 8, -4, 1, -7],
        [9, 1, -3, 4, -1, -7, -1, -2],
        [0, -8, -2, 2, 1, 4, -6, 0],
    ];

    describe('.toDct(mcu)', () => {
        let expected = dctMcu;

        it('Correctly applies FDCT to MCU.', () => {
            jpeg.toDct(testMcu).forEach((rows, i) => {
                rows.forEach((val, j) => {
                    chai.assert.closeTo(val, expected[i][j], 1);
                });
            });
        });
    });

    describe('.fromDct(mcu)', () => {
        let expected = testMcu;

        it('Correctly applies IDCT to MCU (reverts FDCT).', () => {
            jpeg.fromDct(dctMcu).forEach((rows, i) => {
                rows.forEach((val, j) => {
                    chai.assert.closeTo(val, expected[i][j], 1);
                });
            });
        });
    });

    describe('.toBlocks(pxMtx)', () => {
        let args = [
            [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
            [2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3],
            [2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3],
            [2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3],
            [2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3],
            [2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3],
            [2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3],
            [2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3],
            [2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3],
        ];

        let expected = [
            [
                [
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                ],
                [
                    [1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1],
                ],
            ],
            [
                [
                    [2, 2, 2, 2, 2, 2, 2, 2],
                    [2, 2, 2, 2, 2, 2, 2, 2],
                    [2, 2, 2, 2, 2, 2, 2, 2],
                    [2, 2, 2, 2, 2, 2, 2, 2],
                    [2, 2, 2, 2, 2, 2, 2, 2],
                    [2, 2, 2, 2, 2, 2, 2, 2],
                    [2, 2, 2, 2, 2, 2, 2, 2],
                    [2, 2, 2, 2, 2, 2, 2, 2],
                ],
                [
                    [3, 3, 3, 3, 3, 3, 3, 3],
                    [3, 3, 3, 3, 3, 3, 3, 3],
                    [3, 3, 3, 3, 3, 3, 3, 3],
                    [3, 3, 3, 3, 3, 3, 3, 3],
                    [3, 3, 3, 3, 3, 3, 3, 3],
                    [3, 3, 3, 3, 3, 3, 3, 3],
                    [3, 3, 3, 3, 3, 3, 3, 3],
                    [3, 3, 3, 3, 3, 3, 3, 3],
                ],
            ],
        ];

        it('Correctly splits pixel matrix into 8x8 MCUs.', () => {
            chai.assert.deepStrictEqual(jpeg.toBlocks(args), expected);
        });
    });

    describe('.fromBlocks(mcuMtx)', () => {
        let expected = [
            [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
            [2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3],
            [2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3],
            [2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3],
            [2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3],
            [2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3],
            [2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3],
            [2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3],
            [2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3],
        ];

        let args = [
            [
                [
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                ],
                [
                    [1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1],
                ],
            ],
            [
                [
                    [2, 2, 2, 2, 2, 2, 2, 2],
                    [2, 2, 2, 2, 2, 2, 2, 2],
                    [2, 2, 2, 2, 2, 2, 2, 2],
                    [2, 2, 2, 2, 2, 2, 2, 2],
                    [2, 2, 2, 2, 2, 2, 2, 2],
                    [2, 2, 2, 2, 2, 2, 2, 2],
                    [2, 2, 2, 2, 2, 2, 2, 2],
                    [2, 2, 2, 2, 2, 2, 2, 2],
                ],
                [
                    [3, 3, 3, 3, 3, 3, 3, 3],
                    [3, 3, 3, 3, 3, 3, 3, 3],
                    [3, 3, 3, 3, 3, 3, 3, 3],
                    [3, 3, 3, 3, 3, 3, 3, 3],
                    [3, 3, 3, 3, 3, 3, 3, 3],
                    [3, 3, 3, 3, 3, 3, 3, 3],
                    [3, 3, 3, 3, 3, 3, 3, 3],
                    [3, 3, 3, 3, 3, 3, 3, 3],
                ],
            ],
        ];

        it('Correctly forms component from MCU matrix.', () => {
            //chai.assert.deepStrictEqual(jpeg.fromBlocks(args), expected);
        });
    });

    describe('.toDctMap(mcuArr)', () => {
        let testMcuArr = [
            [
                [140, 144, 147, 140, 140, 155, 179, 175],
                [144, 152, 140, 147, 140, 148, 167, 179],
                [152, 155, 136, 167, 163, 162, 152, 172],
                [168, 145, 156, 160, 152, 155, 136, 160],
                [162, 148, 156, 148, 140, 136, 147, 162],
                [147, 167, 140, 155, 155, 140, 136, 162],
                [136, 156, 123, 167, 162, 144, 140, 147],
                [148, 155, 136, 155, 152, 147, 147, 136],
            ],
            [
                [140, 144, 147, 140, 140, 155, 179, 175],
                [144, 152, 140, 147, 140, 148, 167, 179],
                [152, 155, 136, 167, 163, 162, 152, 172],
                [168, 145, 156, 160, 152, 155, 136, 160],
                [162, 148, 156, 148, 140, 136, 147, 162],
                [147, 167, 140, 155, 155, 140, 136, 162],
                [136, 156, 123, 167, 162, 144, 140, 147],
                [148, 155, 136, 155, 152, 147, 147, 136],
            ],
        ];

        let dctMcuArr = [
            [
                [1210, -18, 15, -9, 23, -9, -14, -19],
                [21, -34, 26, -9, -11, 11, 14, 7],
                [-10, -24, -2, 6, -18, 3, -20, -1],
                [-8, -5, 14, -15, -8, -3, -3, 8],
                [-3, 10, 8, 1, -11, 18, 18, 15],
                [4, -2, -18, 8, 8, -4, 1, -7],
                [9, 1, -3, 4, -1, -7, -1, -2],
                [0, -8, -2, 2, 1, 4, -6, 0],
            ],
            [
                [1210, -18, 15, -9, 23, -9, -14, -19],
                [21, -34, 26, -9, -11, 11, 14, 7],
                [-10, -24, -2, 6, -18, 3, -20, -1],
                [-8, -5, 14, -15, -8, -3, -3, 8],
                [-3, 10, 8, 1, -11, 18, 18, 15],
                [4, -2, -18, 8, 8, -4, 1, -7],
                [9, 1, -3, 4, -1, -7, -1, -2],
                [0, -8, -2, 2, 1, 4, -6, 0],
            ],
        ];

        it('Correctly maps FDCT.', () => {
            jpeg.toDctMap(testMcuArr).forEach((mcu, i) => {
                mcu.forEach((row, j) => {
                    row.forEach((val, k) => {
                        chai.assert.closeTo(val, dctMcuArr.slice()[i][j][k], 1);
                    });
                });
            });
        });
    });

    describe('.fromDctMap(mcuArr)', () => {
        let testMcuArr = [
            [
                [140, 144, 147, 140, 140, 155, 179, 175],
                [144, 152, 140, 147, 140, 148, 167, 179],
                [152, 155, 136, 167, 163, 162, 152, 172],
                [168, 145, 156, 160, 152, 155, 136, 160],
                [162, 148, 156, 148, 140, 136, 147, 162],
                [147, 167, 140, 155, 155, 140, 136, 162],
                [136, 156, 123, 167, 162, 144, 140, 147],
                [148, 155, 136, 155, 152, 147, 147, 136],
            ],
            [
                [140, 144, 147, 140, 140, 155, 179, 175],
                [144, 152, 140, 147, 140, 148, 167, 179],
                [152, 155, 136, 167, 163, 162, 152, 172],
                [168, 145, 156, 160, 152, 155, 136, 160],
                [162, 148, 156, 148, 140, 136, 147, 162],
                [147, 167, 140, 155, 155, 140, 136, 162],
                [136, 156, 123, 167, 162, 144, 140, 147],
                [148, 155, 136, 155, 152, 147, 147, 136],
            ],
        ];

        let dctMcuArr = [
            [
                [1210, -18, 15, -9, 23, -9, -14, -19],
                [21, -34, 26, -9, -11, 11, 14, 7],
                [-10, -24, -2, 6, -18, 3, -20, -1],
                [-8, -5, 14, -15, -8, -3, -3, 8],
                [-3, 10, 8, 1, -11, 18, 18, 15],
                [4, -2, -18, 8, 8, -4, 1, -7],
                [9, 1, -3, 4, -1, -7, -1, -2],
                [0, -8, -2, 2, 1, 4, -6, 0],
            ],
            [
                [1210, -18, 15, -9, 23, -9, -14, -19],
                [21, -34, 26, -9, -11, 11, 14, 7],
                [-10, -24, -2, 6, -18, 3, -20, -1],
                [-8, -5, 14, -15, -8, -3, -3, 8],
                [-3, 10, 8, 1, -11, 18, 18, 15],
                [4, -2, -18, 8, 8, -4, 1, -7],
                [9, 1, -3, 4, -1, -7, -1, -2],
                [0, -8, -2, 2, 1, 4, -6, 0],
            ],
        ];

        it('Correctly maps IDCT.', () => {
            jpeg.fromDctMap(dctMcuArr).forEach((mcu, i) => {
                mcu.forEach((row, j) => {
                    row.forEach((val, k) => {
                        chai.assert.closeTo(
                            val,
                            testMcuArr.slice()[i][j][k],
                            1,
                        );
                    });
                });
            });
        });
    });

    describe('.sample(component, rate)', () => {
        let comp = [
            [140, 144, 147, 140, 140, 155, 179, 175],
            [144, 152, 140, 147, 140, 148, 167, 179],
            [152, 155, 136, 167, 163, 162, 152, 172],
            [168, 145, 156, 160, 152, 155, 136, 160],
            [162, 148, 156, 148, 140, 136, 147, 162],
            [147, 167, 140, 155, 155, 140, 136, 162],
            [136, 156, 123, 167, 162, 144, 140, 147],
            [148, 155, 136, 155, 152, 147, 147, 136],
        ];

        it('should scale down a matrix when 4:2:0', () => {});

        it('should scale up a matrix to 4:4:4, when prev downscaled', () => {
            let downscaled = sample([comp, comp, comp], [4, 2, 1]);

            console.table(downscaled[2]);
            console.table(sampleUp(downscaled)[2]);
            let upscaled = upscaleComps(downscaled, [4, 2, 2]);

            /* test downscaling */
            chai.assert.strictEqual(downscaled[0].length, comp.length);
            chai.assert.strictEqual(downscaled[1][0].length, comp.length / 2);
            chai.assert.strictEqual(
                downscaled[1][0].length,
                comp[0].length / 2,
            );

            console.table(upscaled[2]);
            console.log(comp[0]);
            chai.assert.strictEqual(upscaled[1].length, comp.length);
            chai.assert.strictEqual(upscaled[1][0].length, comp.length);
        });
    });

    describe('.quantise(mcu)', () => {
        let testMcu = [
            [140, 144, 147, 140, 140, 155, 179, 175],
            [144, 152, 140, 147, 140, 148, 167, 179],
            [152, 155, 136, 167, 163, 162, 152, 172],
            [168, 145, 156, 160, 152, 155, 136, 160],
            [162, 148, 156, 148, 140, 136, 147, 162],
            [147, 167, 140, 155, 155, 140, 136, 162],
            [136, 156, 123, 167, 162, 144, 140, 147],
            [148, 155, 136, 155, 152, 147, 147, 136],
        ];

        it('Correctly scales MCU');
    });
});
